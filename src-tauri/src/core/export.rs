use printpdf::*;
use std::fs::File;
use std::io::BufWriter;
use chrono::Local;

/// Report data structure
#[derive(serde::Deserialize, Clone)]
pub struct ReportData {
    pub title: String,
    pub summary: String,
    pub threats: Vec<ThreatEntry>,
    pub devices: Vec<DeviceEntry>,
    pub ai_analysis: Option<String>,
}

#[derive(serde::Deserialize, Clone)]
pub struct ThreatEntry {
    pub timestamp: String,
    pub threat_type: String,
    pub source_ip: String,
    pub severity: String,
}

#[derive(serde::Deserialize, Clone)]
pub struct DeviceEntry {
    pub ip: String,
    pub mac: String,
    pub os: Option<String>,
    pub packet_count: u64,
}

/// Generate a PDF report from the given data
pub fn generate_pdf(data: &ReportData, output_path: &str) -> Result<String, String> {
    // Create PDF document
    let (doc, page1, layer1) = PdfDocument::new(
        &data.title,
        Mm(210.0),  // A4 width
        Mm(297.0),  // A4 height
        "Layer 1"
    );
    
    let current_layer = doc.get_page(page1).get_layer(layer1);
    
    // Load a built-in font
    let font = doc.add_builtin_font(BuiltinFont::Helvetica)
        .map_err(|e| format!("Font error: {}", e))?;
    let font_bold = doc.add_builtin_font(BuiltinFont::HelveticaBold)
        .map_err(|e| format!("Font error: {}", e))?;
    
    let mut y_position = Mm(280.0);
    
    // === HEADER ===
    current_layer.use_text(&data.title, 24.0, Mm(20.0), y_position, &font_bold);
    y_position = y_position - Mm(10.0);
    
    let date_str = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    current_layer.use_text(&format!("Generated: {}", date_str), 10.0, Mm(20.0), y_position, &font);
    y_position = y_position - Mm(15.0);
    
    // === SUMMARY ===
    current_layer.use_text("Summary", 14.0, Mm(20.0), y_position, &font_bold);
    y_position = y_position - Mm(7.0);
    
    // Split summary into lines (max 80 chars per line)
    for line in wrap_text(&data.summary, 80) {
        current_layer.use_text(&line, 10.0, Mm(20.0), y_position, &font);
        y_position = y_position - Mm(5.0);
    }
    y_position = y_position - Mm(10.0);
    
    // === THREATS ===
    if !data.threats.is_empty() {
        current_layer.use_text(&format!("Threats Detected: {}", data.threats.len()), 14.0, Mm(20.0), y_position, &font_bold);
        y_position = y_position - Mm(7.0);
        
        for threat in data.threats.iter().take(10) {
            let line = format!("[{}] {} - {} ({})", threat.severity, threat.threat_type, threat.source_ip, threat.timestamp);
            current_layer.use_text(&line, 9.0, Mm(25.0), y_position, &font);
            y_position = y_position - Mm(5.0);
            
            if y_position < Mm(30.0) {
                break; // Prevent overflow
            }
        }
        y_position = y_position - Mm(10.0);
    }
    
    // === DEVICES ===
    if !data.devices.is_empty() {
        current_layer.use_text(&format!("Active Devices: {}", data.devices.len()), 14.0, Mm(20.0), y_position, &font_bold);
        y_position = y_position - Mm(7.0);
        
        for device in data.devices.iter().take(15) {
            let os_str = device.os.as_deref().unwrap_or("Unknown");
            let line = format!("{} | {} | {} | {} pkts", device.ip, device.mac, os_str, device.packet_count);
            current_layer.use_text(&line, 9.0, Mm(25.0), y_position, &font);
            y_position = y_position - Mm(5.0);
            
            if y_position < Mm(30.0) {
                break;
            }
        }
        y_position = y_position - Mm(10.0);
    }
    
    // === AI ANALYSIS ===
    if let Some(ref analysis) = data.ai_analysis {
        if y_position > Mm(50.0) {
            current_layer.use_text("AI Analysis", 14.0, Mm(20.0), y_position, &font_bold);
            y_position = y_position - Mm(7.0);
            
            for line in wrap_text(analysis, 80).iter().take(5) {
                current_layer.use_text(line, 9.0, Mm(25.0), y_position, &font);
                y_position = y_position - Mm(5.0);
            }
        }
    }
    
    // === FOOTER ===
    current_layer.use_text("Generated by DeepSide v0.1.0", 8.0, Mm(20.0), Mm(15.0), &font);
    
    // Save PDF
    let file = File::create(output_path)
        .map_err(|e| format!("Failed to create file: {}", e))?;
    let writer = BufWriter::new(file);
    
    doc.save(&mut std::io::BufWriter::new(writer))
        .map_err(|e| format!("Failed to save PDF: {}", e))?;
    
    Ok(output_path.to_string())
}

/// Wrap text to specified width
fn wrap_text(text: &str, max_chars: usize) -> Vec<String> {
    let mut lines = Vec::new();
    let mut current_line = String::new();
    
    for word in text.split_whitespace() {
        if current_line.len() + word.len() + 1 > max_chars {
            if !current_line.is_empty() {
                lines.push(current_line.clone());
                current_line.clear();
            }
        }
        if !current_line.is_empty() {
            current_line.push(' ');
        }
        current_line.push_str(word);
    }
    
    if !current_line.is_empty() {
        lines.push(current_line);
    }
    
    lines
}

/// Tauri command to export PDF
#[tauri::command]
pub async fn export_report_pdf(
    app: tauri::AppHandle,
    data: ReportData,
) -> Result<String, String> {
    use tauri::Manager;
    
    // Get Downloads folder or app data dir
    let download_dir = app.path().download_dir()
        .unwrap_or_else(|_| app.path().app_data_dir().unwrap());
    
    let timestamp = Local::now().format("%Y%m%d_%H%M%S");
    let filename = format!("deepside_report_{}.pdf", timestamp);
    let output_path = download_dir.join(&filename);
    
    generate_pdf(&data, output_path.to_str().unwrap())?;
    
    Ok(output_path.to_string_lossy().to_string())
}
